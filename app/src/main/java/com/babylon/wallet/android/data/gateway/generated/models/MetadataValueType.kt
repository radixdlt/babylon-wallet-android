/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.babylon.wallet.android.data.gateway.generated.models


import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

/**
 * 
 *
 * Values: String,Bool,U8,U32,U64,I32,I64,Decimal,GlobalAddress,PublicKey,NonFungibleGlobalId,NonFungibleLocalId,Instant,Url,Origin,PublicKeyHash,StringArray,BoolArray,U8Array,U32Array,U64Array,I32Array,I64Array,DecimalArray,GlobalAddressArray,PublicKeyArray,NonFungibleGlobalIdArray,NonFungibleLocalIdArray,InstantArray,UrlArray,OriginArray,PublicKeyHashArray
 */
@Serializable
enum class MetadataValueType(val value: kotlin.String) {

    @SerialName(value = "String")
    String("String"),

    @SerialName(value = "Bool")
    Bool("Bool"),

    @SerialName(value = "U8")
    U8("U8"),

    @SerialName(value = "U32")
    U32("U32"),

    @SerialName(value = "U64")
    U64("U64"),

    @SerialName(value = "I32")
    I32("I32"),

    @SerialName(value = "I64")
    I64("I64"),

    @SerialName(value = "Decimal")
    Decimal("Decimal"),

    @SerialName(value = "GlobalAddress")
    GlobalAddress("GlobalAddress"),

    @SerialName(value = "PublicKey")
    PublicKey("PublicKey"),

    @SerialName(value = "NonFungibleGlobalId")
    NonFungibleGlobalId("NonFungibleGlobalId"),

    @SerialName(value = "NonFungibleLocalId")
    NonFungibleLocalId("NonFungibleLocalId"),

    @SerialName(value = "Instant")
    Instant("Instant"),

    @SerialName(value = "Url")
    Url("Url"),

    @SerialName(value = "Origin")
    Origin("Origin"),

    @SerialName(value = "PublicKeyHash")
    PublicKeyHash("PublicKeyHash"),

    @SerialName(value = "StringArray")
    StringArray("StringArray"),

    @SerialName(value = "BoolArray")
    BoolArray("BoolArray"),

    @SerialName(value = "U8Array")
    U8Array("U8Array"),

    @SerialName(value = "U32Array")
    U32Array("U32Array"),

    @SerialName(value = "U64Array")
    U64Array("U64Array"),

    @SerialName(value = "I32Array")
    I32Array("I32Array"),

    @SerialName(value = "I64Array")
    I64Array("I64Array"),

    @SerialName(value = "DecimalArray")
    DecimalArray("DecimalArray"),

    @SerialName(value = "GlobalAddressArray")
    GlobalAddressArray("GlobalAddressArray"),

    @SerialName(value = "PublicKeyArray")
    PublicKeyArray("PublicKeyArray"),

    @SerialName(value = "NonFungibleGlobalIdArray")
    NonFungibleGlobalIdArray("NonFungibleGlobalIdArray"),

    @SerialName(value = "NonFungibleLocalIdArray")
    NonFungibleLocalIdArray("NonFungibleLocalIdArray"),

    @SerialName(value = "InstantArray")
    InstantArray("InstantArray"),

    @SerialName(value = "UrlArray")
    UrlArray("UrlArray"),

    @SerialName(value = "OriginArray")
    OriginArray("OriginArray"),

    @SerialName(value = "PublicKeyHashArray")
    PublicKeyHashArray("PublicKeyHashArray");

    /**
     * Override [toString()] to avoid using the enum variable name as the value, and instead use
     * the actual value defined in the API spec file.
     *
     * This solves a problem when the variable name and its value are different, and ensures that
     * the client sends the correct enum values to the server always.
     */
    override fun toString(): kotlin.String = value

    companion object {
        /**
         * Converts the provided [data] to a [String] on success, null otherwise.
         */
        fun encode(data: kotlin.Any?): kotlin.String? = if (data is MetadataValueType) "$data" else null

        /**
         * Returns a valid [MetadataValueType] for [data], null otherwise.
         */
        fun decode(data: kotlin.Any?): MetadataValueType? = data?.let {
          val normalizedData = "$it".lowercase()
          values().firstOrNull { value ->
            it == value || normalizedData == "$value".lowercase()
          }
        }
    }
}

