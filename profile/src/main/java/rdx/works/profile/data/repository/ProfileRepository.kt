package rdx.works.profile.data.repository

import com.radixdlt.sargon.CommonException
import com.radixdlt.sargon.DeviceInfo
import com.radixdlt.sargon.Profile
import com.radixdlt.sargon.ProfileState
import com.radixdlt.sargon.extensions.from
import com.radixdlt.sargon.extensions.fromJson
import com.radixdlt.sargon.os.SargonOsManager
import com.radixdlt.sargon.os.driver.AndroidProfileStateChangeDriver
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.filterIsInstance
import kotlinx.coroutines.flow.filterNotNull
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import rdx.works.core.TimestampGenerator
import rdx.works.core.di.ApplicationScope
import rdx.works.core.di.IoDispatcher
import rdx.works.core.preferences.PreferencesManager
import rdx.works.core.sargon.canBackupToCloud
import rdx.works.profile.cloudbackup.CloudBackupSyncExecutor
import rdx.works.profile.datastore.EncryptedPreferencesManager
import timber.log.Timber
import javax.inject.Inject

interface ProfileRepository {

    val profileState: Flow<ProfileState>

    val inMemoryProfileOrNull: Profile?

    suspend fun saveProfile(profile: Profile)

    suspend fun clearAllWalletData()

    fun deriveProfileState(content: String): ProfileState
}

suspend fun ProfileRepository.updateProfile(updateAction: suspend (Profile) -> Profile): Profile {
    val profile = profile.first()
    val updatedProfile = updateAction(profile)
    saveProfile(updatedProfile)
    return updatedProfile
}

val ProfileRepository.profile: Flow<Profile>
    get() = profileState
        .filterIsInstance<ProfileState.Loaded>()
        .map { it.v1 }

@Suppress("LongParameterList")
class ProfileRepositoryImpl @Inject constructor(
    private val encryptedPreferencesManager: EncryptedPreferencesManager,
    private val preferencesManager: PreferencesManager,
    private val cloudBackupSyncExecutor: CloudBackupSyncExecutor,
    private val sargonOsManager: SargonOsManager,
    private val hostInfoRepository: HostInfoRepository,
    private val profileStateChangeDriver: AndroidProfileStateChangeDriver,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,
    @ApplicationScope applicationScope: CoroutineScope
) : ProfileRepository {

    init {
        applicationScope.launch {
            profileStateChangeDriver
                .profile
                .collect { state ->
                    if (state.canBackupToCloud) {
                        cloudBackupSyncExecutor.requestCloudBackup()
                    } else {
                        encryptedPreferencesManager.clearProfileSnapshotFromCloudBackup()
                    }
                }
        }
    }

    override val profileState = profileStateChangeDriver
        .profileState
        // Waits until the profile state is evaluated
        .filterNotNull()

    override val inMemoryProfileOrNull: Profile?
        get() = when (val state = profileStateChangeDriver.profileState.value) {
            is ProfileState.Loaded -> state.v1
            else -> null
        }

    override suspend fun saveProfile(profile: Profile) {
        val sargonOs = sargonOsManager.sargonOs
        val hostId = hostInfoRepository.getHostId().getOrNull() ?: return
        val hostInfo = hostInfoRepository.getHostInfo().getOrNull() ?: return

        val profileToSave = profile.copy(
            header = profile.header.copy(
                lastModified = TimestampGenerator(),
                // In general this would be unnecessary. Meaning that a new user will generate a device id and store it in profile
                // or restore from backup, generated a new device id and claim the profile. In both situations the device info should
                // have the correct up-to-date device id.
                // The problem lies to existing users: Those who updated from a version prior to 1.6.0. In later versions the android app
                // introduced the concept of device id, which is stored in preferences. These users need to silently update their
                // lastUsedOnDevice  to have the current information about the device id. Profiles prior to this, which were generated by
                // the android app had device id == profile id
                lastUsedOnDevice = DeviceInfo.from(hostId, hostInfo)
            )
        )

        withContext(ioDispatcher) {
            sargonOs.setProfile(profileToSave)
        }
    }

    override suspend fun clearAllWalletData() {
        val sargonOs = sargonOsManager.sargonOs

        preferencesManager.clear()

        sargonOs.deleteWallet()
    }

    @Suppress("SwallowedException")
    override fun deriveProfileState(content: String): ProfileState = runCatching {
        Profile.fromJson(content)
    }.fold(
        onSuccess = {
            ProfileState.Loaded(it)
        },
        onFailure = {
            Timber.w(it)
            ProfileState.Incompatible(it as CommonException)
        }
    )
}
